# -*- coding: utf-8 -*-
"""
Implemented:
- .ref

Missing:
- .m42
- .m40
- .m50
...
"""

import shutil
from pathlib import Path

from abc import ABC, abstractmethod
from dataclasses import dataclass

#import pandas as pd
#import numpy as np

from datetime import datetime, time, date

# decorators: 
# @dataclass: autogenerated methods __init__ and __repr__
# @abstractmethod: enforce implementation


# @property (getter, setter) = access method as if it was a property
# @staticmethod (independent of class or instance)
# NN @contextmanager: enable >>> with function_call as f: # https://realpython.com/python-with-statement/

@dataclass
class BaseFileHandler(ABC):
    """
    Base file handler
    Other file handlers are based on this class.
    abstractmethod: classes based on this class are required to implement this method
    """
    filepath : str
    # mode : "read" | "create" |
    
    def __post_init__(self):
        # use pathlib
        self.filepath = Path( self.filepath )
        
        # read file after initialisation
        # Creator Mode:
        # if self.mode == "read": # and self.mode != "create":
        self.read() 

    @abstractmethod
    def read(self):
        """Read the file content."""
        pass
    
    @abstractmethod
    def create(self):
        """
        method to create this file
        """
        pass

    @abstractmethod
    def update(self, data):
        """Update the file with new data."""
        pass

    def copy(self, destination):
        """Copy the file to a new destination."""
        try:
            shutil.copy2(self.filepath, destination)
            print(f"File copied to {destination}")
            return True
        except Exception as e:
            print(f"Error copying file: {e}")
            return False

    def delete(self):
        """Delete the file."""
        try:
            self.filepath.unlink()
            print(f"File {self.filepath} deleted.")
            return True
        except Exception as e:
            print(f"Error deleting file: {e}")
            return False
        

###
### JANA
###

@dataclass
class RefFileHandler(BaseFileHandler):
    """
    RefFileHandler hosts similar data like m83 + R factors + ...
    
    Does it make sense to have methods to fill data from m83, m50, etc?
    Make this rather a refinement data object and less focussed on REF file
    """
    
    wavelength: float = None # in Ã…
    N_zones: int = 0
    N_blocks: int = 0
    
    N_parameters: int = None
    N_obs: int = None
    N_all: int = None
    N_rejected: int = 0
    max_change: str = None
    
    GoF_obs: float = 0.0
    GoF_all: float = 0.0
    R_obs: float = 0.0
    R_all: float = 0.0
    wR_obs: float = 0.0
    wR_all: float = 0.0
    instability_factor: float = None
    
    N_cycles: int = 0
    timestamp_file: int = 0        # seconds, timestamp     modification date of REF file
    timestamp_start: int = 0       # seconds, timestamp     needs to be guessed
    timestamp_end: int = 0         # seconds, timestamp     given in REF file
    timestamp_last_cycle: int = 0  # seconds, timestamp     modification date of M85 file
    time_start: time = time(0,0,0) #  datetime.time         given in REF file
    time_end: time = time(0,0,0)   #  detetime.time         given in REF file
    runtime_total: int = 0
    runtime_cpu: int  = 0         # seconds, duration
    runtime_non_cpu: int = 0
    runtime_cycles: int = 0
    runtime_per_cycle: int = 0
    runtime_Rfactor: int = 0
    
                    
    
    # reflections: pd.DataFrame # reflections in REF file are usually incomplete. Read M80 or M83 to get reflections.
    # Better support for multiblock refinements.
    
    def read(self):
        """
        read file, update object properties
        """
        
        # timestamp of file modification
        self.timestamp_file = int( self.filepath.lstat().st_mtime )
        
        Lines = self.filepath.read_text().split("\n")

        ReadReflections = False
        # Reflections = []
        # ref["Reflections"] = pd.DataFrame(Reflections, columns="hkl, Fo, Fc, Fsigma, Fweight, wDF, KickFlag, dstar, Frame#".split(", "))
        
        # read file from top to bottom
        for i, line in enumerate(Lines):
            ''' # skip reading reflections
            if ReadReflections and len(line) >= 120 and line[17] == "." and line[27] == ".":
                h = int(line[0:4])
                k = int(line[4:8])
                l = int(line[8:12])    
                Fo = float(line[12:22])
                Fc = float(line[22:32])
                Fsigma = float(line[62:72])
                Fweight = 1/float(line[72:82])
                dstar = 2*float(line[102:110])
                #wDF = Fweight*(Fo-Fc)
                wDF = float(line[82:92])
                ObsFlag = 0 if line[99] == "*" else 1
                KickFlag = 1 if line[100] == "#" else 0
                FrameID = int(line[116:119])
                Reflections.append( ( (h,k,l), Fo, Fc, Fsigma, Fweight, wDF, KickFlag, dstar, FrameID ) )
            elif line.startswith("* Fo/Fc list of worst fitted reflections"):
                ReadReflections = False
            '''
            if "Wave length" in line:
                self.wavelength = float(line[12:-1])
            elif ( "Zone#" in line and not line.startswith("|Maximum change") ) or line.startswith("Sample thicknesses are supposed"):
                #print(ref["Zones"], line,end="")
                self.N_zones += 1
            elif "* Fo/Fc list after last cycle" in line:
                #ReadReflections = True
                self.N_blocks += 1
            elif "coefficient of unstability" in line: #s.i.c.
                self.instability_factor = float(line.split()[-1])
                ####################################################################
            elif "Damping factor:" in line: # read N, R, GoF
                """
                ------------------------------------------------------------------------------
                |R factors : [5932=4912+1020/65],    Damping factor:   1.0000                |
                |GOF(obs)=  2.11    GOF(all)=  1.95                                          |
                |R(obs)=   5.32    wR(obs)=   5.64    R(all)=    5.82    wR(all)=       5.72 |
                |Last wR(all):  5.72  5.72                                                   |
                |Maximum change/s.u. :    0.1439 for EDMAve                                  |
                ------------------------------------------------------------------------------
                """
                # [Nall=___+Nobs/Nparameters]
                PosL = line.index("[") 
                PosE = line.index("=")
                PosP = line.index("+")
                PosS = line.index("/")
                PosR = line.index("]")
                
                # number of reflections
                self.N_all = int(line[PosL+1:PosE])
                self.N_obs = int(line[PosE+1:PosP])
                
                # number of rejected reflections (filter)
                if Lines[i+2].startswith("|Number of reflections excluded due to refinement options"):
                    PosC = Lines[i+2].index(":")
                    PosP = Lines[i+2].index("+")
                    self.N_rejected = int(Lines[i+2][PosC+1:PosP]) + int(Lines[i+2][PosP+1:PosP+4])
                    iR = i+3 # line id where to expect R factors
                else:
                    iR = i+2
                
                # number of refined parameters
                tmp = line[PosS+1:PosR]
                if "-" in tmp:
                    self.N_parameters = int(tmp.split("-")[0]) - int(tmp.split("-")[1])
                else:
                    self.N_parameters = int(tmp)
                
                # goodness of fit
                self.GoF_obs = float( Lines[i+1][11:16].strip() )
                self.GoF_all = float( Lines[i+1][30:35].strip() )
                
                # iR: line with R factors
                R_factors = Lines[iR].split()
                R_factors = [ float(R_factors[i]) for i in (1,3,5,7) ]
                self.R_obs, self.wR_obs, self.R_all, self.wR_all = R_factors
                
                if Lines[i+4].startswith("|Maximum"):
                    self.max_change = Lines[i+4][24:70].strip() # maximum change / s.u.
                
                #else: # kinematical case
                #    print("Kinematical refinement.")
                #    break
            elif line.startswith("Cycle   Robs  wRobs   Rall"):
                """
                Cycle   Robs  wRobs   Rall  wRall  nobs  nall   np nall/np nskip nover  damp  gofobs gofall av ch/su       max ch/su            
                   0    5.32   5.64   5.82   5.72  4912  5932   65   91.26     0     0 1.0000   2.11   1.95   0.1724     0.5218 EDThick[Zone#1] 
                   1    5.32   5.64   5.82   5.72  4912  5932   65   91.26     0     0 1.0000   2.11   1.95   0.0057     0.1439 EDMAve          
                   2    5.32   5.64   5.82   5.72  4912  5932   65   91.26                                                                      
                """
                for j in range(7,0,-1):
                    tmp = Lines[i+j]
                    if len(tmp) > 10 and tmp[9] == ".":
                        self.N_cycles = int( Lines[i+j].split()[0] )
                        break
            elif line.startswith("* Changes overview *"):
                break   
        
        # read from bottom to top
        for line in Lines[-60:]:
            # CPU runtime from last line(s)
            if line.startswith("Program started"):
                """ Program started at 18:39:44 ended   at 22:29:57 cpu time :   4674.43 """
                self.runtime_cpu = int( round( float(line.split()[-1]), 0) ) # seconds
                
                # from REF file
                self.time_start = time.fromisoformat( line.split()[3] )
                self.time_end = time.fromisoformat( line.split()[6] )   # time object with .hour .minute .second                
            elif line.startswith("structure :") and line.count("-") >= 2 and line.count(":") >= 2:
                """ structure :                                                                                                18:39:44 24-09-25 """
                # start date: header line of ref file
                ### Date in first header lines and last header lines may differ!
                ### In one case 16 header lines showed the date and time when the refinement started. 
                ### The last 190 header lines showed the date when the file was written after the refinement finished.
                time_start, date_start = line.split()[-2:]
                time_start = time.fromisoformat( time_start )
                
                day_start, month_start, year_start = [ int(e) for e in date_start.split("-") ] # JANA: Day-Month-Year
                date_start = date(year_start + 2000, month_start, day_start)
                
                # timestamp
                self.timestamp_start = int( datetime.timestamp( datetime.combine(date_start, time_start) ) )
                
    #####################################################################################
    
    @staticmethod
    def duration_format(duration: int|float) -> str:
        """
        duration: Duration in seconds
        
        Returns a string expressing the duration in hours:minutes:seconds
        
        Example: duration_format(2*3600 + 1*60 + 7) == "2:01:07"
        """
        return f"{int(duration//3600)}:{int(duration%3600)//60:02d}:{int(duration%60)//1:02d}"    
        
    def analyse_refinement_runtime(self):
        """
        [ ] Todo: use timestamps of s40 and s83 files
        
        Combine all available time data to determine how much time was spent
        on the refinement and on each refinement cycle.
               
        If JANA runs for N refinement cycles and N > 0:
            Cycle 0: FIRST refinement cycle. Calculates intensities and derivatives. Updates parameters.
            Cycle N-1: LAST refinement cycle. Calculates intensities and derivatives. Updates parameters.
            Cycle N: R-factor cycle. Calculates intensities. Derivatives are NOT calculated. Parameters are NOT updated.

            t0: Before Cycle 0, the clock time is written in the REF file. t0 is the start time of the refinement.
            tN: After Cycle N-1, the M85 file is written. tN is the timestampe of the last file modification (M85).
            tR: After Cycle N, the REF file is written. tR is the timestamp of the last file modification (REF).
            
        If JANA runs for 0 refinement cycles N = 0:
            Cycle 0 is the R-factor cycle.
            
            t0 = tN
            
        Total time = tR - t0
        Refinement cycle runtime = (tN - t0) / N
        R-factor cycle runtime = tR - tN

        tN is not written into any file by JANA. However, at tN the M85 file is written.
        The file modification date of the original M85 file can thus be used to determine tN.
        However, if M85 is not available or the file was transferred, tN cannot be determined.
        In this case, it is assumed that tN = tR and that the R-factor cycle had a duration of 0 seconds.
        
        Usually, the R-factor cycle is much faster than a refinement cycle.
        """
        
        ###
        #   Can the DATE of the end of the refinement derived from the file time stamp? 
        ###
        
        # Check timestamp of REF file modification        
        file_datetime = datetime.fromtimestamp( self.timestamp_file )
        file_date = file_datetime.date()
        file_time = file_datetime.time()
        
        # difference between time from REF and time from FILE
        today = datetime.today().date() # arbitrary date
        delta = (datetime.combine(today, file_time) - datetime.combine(today, self.time_end)).total_seconds()
                    
        if abs(delta) < 5:
            # file modification time and time given in REF agree (within <5 seconds)
            # time modification timestamp can be used
            self.timestamp_end = int( self.timestamp_file )
        else:
            # derive date based on CPU time
            # This approach may yield wrong results! However, if refinement runtime < 48 hours, this approach should work.
            cpu_days = int( self.runtime_cpu / (24*60*60) )
            time_delta = (datetime.combine(today, self.time_end) - datetime.combine(today, self.time_start)).total_seconds()
            
            self.timestamp_end = int( self.timestamp_start + time_delta + cpu_days * 24*60*60 )
            
            if self.timestamp_end < self.timestamp_start:
                self.timestamp_end += 24*60*60
                
        self.runtime_total = self.timestamp_end - self.timestamp_start
        self.runtime_non_cpu = self.runtime_total - self.runtime_cpu 
            
        ###
        #   Determine timestamp of end of last refinement cycle = beginning of R-factor cycle
        #   + runtime for all cycles + runtime per cycle
        ###
        if self.N_cycles > 0:
            # at least 1 full refinement cycle
            m85_file = self.filepath.with_suffix(".m85")
            if m85_file.exists():
                tN = m85_file.lstat().st_mtime
                if self.timestamp_start < tN < self.timestamp_end:
                    # reasonable timestamp
                    self.timestamp_last_cycle = int(tN)
                    self.runtime_cycles = self.timestamp_last_cycle - self.timestamp_start
                    self.runtime_per_cycle = self.runtime_cycles / self.N_cycles
                    self.runtime_Rfactor = self.runtime_total - self.runtime_cycles
                else:
                    # timestamp not reasonable, ignore
                    print()
                    print("    !! Timestamp of end of last refinement cycle could not be determined.")
                    print("    !! Assuming the R-factor cycle took 0 seconds!")
                    self.runtime_cycles = self.runtime_total
                    self.runtime_per_cycle = self.runtime_cycles / self.N_cycles
                    self.runtime_Rfactor = 0
        else:
            # 0 cycles
            # no m85 file expected or m85 file not relevant for this refinement
            self.runtime_cycles = 0
            self.runtime_Rfactor = self.runtime_total

                
    def report_runtime(self):
        print("- "*40)
        print("       Duration format >> hours:minutes:seconds")
        # express seconds in hhh:mm:ss
        #duration_format = lambda t: f"{int(t//3600)}:{int(t%3600)//60:02d}:{int(t%60)//1:02d}"
        
        if not self.timestamp_end:
            self.analyse_refinement_runtime()
             
        print()
        print("Refinement:")
        print("***********")
        print(f" # of parameters:     {self.N_parameters:10d}")
        print(f" # of reflections:    {self.N_all:10d}")
        print(f" # of cycles N:       {self.N_cycles:10d} <-- with derivatives and parameter shifts")
        print(f" # of R-factor cycles:{1:10d} <-- no derivatives, no parameter shifts")
        print(f"CPU time:             {self.duration_format(self.runtime_cpu):>10} <-- JANA + DYNGO")
        print(f"Non-CPU time:         {self.duration_format(self.runtime_non_cpu):>10} <-- Read/Write files")
            
        if self.N_cycles == 0:
            # only R-factor cycle
            print()
            print("R-factor cycle")
            print("**************")
            print("Start:                ", datetime.fromtimestamp(self.timestamp_start) )
            print("End:                  ", datetime.fromtimestamp(self.timestamp_end) )
            print("Duration:             ", self.duration_format(self.runtime_total) )
        else:
            print()
            print("Refinement timestamps:")
            print("*******************")            
            print("Start Refinement:     ", datetime.fromtimestamp(self.timestamp_start) )
            print("Start R-factor cycle: ", datetime.fromtimestamp(self.timestamp_last_cycle) )
            print("End:                  ", datetime.fromtimestamp(self.timestamp_end) )
            
            print()
            print("Refinement runtime:")
            print("*******************")
            print(f" Runtime N cycles:    {self.duration_format(self.runtime_cycles):>10} <-- without R-factor cycle")
            print(f" R-factor cycle:    + {self.duration_format(self.runtime_Rfactor):>10} <-- no derivatives, no parameter shifts")
            print( "                      ----------") 
            print(f" Total runtime:     = {self.duration_format(self.runtime_total):>10}")
            print()#"- "*40)
            print(f" Runtime per cycle:   {self.duration_format(self.runtime_per_cycle):>10} <-- with derivatives and parameter shifts")   
            print()
            print("- "*40)
        return True


    def update(self, data):
        """
        ref files cannot be updated.
        """
        print("REF files cannot be updated")
        
    def create(self):
        """
        ref files cannot be created.
        However, one could think of constructing some kind of refinement report.
        """
        print("REF files cannot be created. Run JANA again.")
        
    

################# ################# ################# ################# ################# #################
    